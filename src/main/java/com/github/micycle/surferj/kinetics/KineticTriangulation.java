package com.github.micycle.surferj.kinetics;

import org.locationtech.jts.geom.Coordinate;
import org.locationtech.jts.geom.LineSegment;
import org.locationtech.jts.math.Vector2D;
import org.tinfour.common.IQuadEdge;
import org.tinfour.common.SimpleTriangle;
import org.tinfour.common.Vertex;

import com.github.micycle.surferj.SkeletonOutput;
import com.github.micycle.surferj.event.CollapseEvent;
import com.github.micycle.surferj.event.EventQueue;
import com.github.micycle.surferj.event.EventType;
import com.github.micycle.surferj.triangulation.InitialTriangulator;
import com.github.micycle.surferj.util.Constants;
import com.github.micycle.surferj.util.GeometryUtil;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import org.tinfour.common.IIncrementalTin;

/**
 * Manages the dynamic triangulation representing the shrinking area during straight skeleton computation.
 *
 * <h2>Data Structure:</h2>
 * This class maintains a triangulation structure composed of {@link KineticTriangle} objects.
 * It essentially represents a dynamic graph where triangles are nodes. Connectivity is maintained
 * within each {@code KineticTriangle}:
 * <ul>
 *     <li>{@code vertices[3]}: References to the three {@link KineticVertex} objects forming the triangle corners (CCW order).</li>
 *     <li>{@code neighbors[3]}: References to the three adjacent {@code KineticTriangle} objects. A neighbor link exists across an edge if that edge is *internal* to the shrinking region (a "spoke"). If the edge lies on the boundary (the wavefront), the corresponding neighbor is {@code null}.</li>
 *     <li>{@code edges[3]}: References to {@link KineticEdge} objects. An edge link exists *only* if the edge opposite the vertex lies on the moving wavefront (i.e., it's part of the original polygon boundary or a result of beveling/splitting). If the edge is internal ("spoke"), the corresponding edge is {@code null}.</li>
 * </ul>
 * Therefore, for any given side {@code i} of a triangle, exactly one of {@code neighbors[i]} or {@code edges[i]} will be non-null.
 *
 * <p>The {@link KineticVertex} objects represent the moving vertices of the wavefront. Each active wavefront vertex is the intersection of two {@link KineticEdge} supporting lines and stores its velocity.</p>
 * <p>The {@link KineticEdge} objects represent the moving line segments of the wavefront itself. They correspond to the original polygon edges (or edges created by beveling/splitting).</p>
 *
 * <h2>Relationship to TinFour:</h2>
 * The {@code KineticTriangulation} is initialized based on a static triangulation generated by TinFour (via {@link InitialTriangulator}).
 * <ul>
 *     <li>Initial {@code KineticTriangle}s correspond to {@code SimpleTriangle}s from the TIN.</li>
 *     <li>Initial {@code KineticVertex}s correspond to {@code Vertex} objects from the TIN.</li>
 *     <li>Initial {@code KineticEdge}s correspond *only* to the edges marked as constraints in the TIN (which represent the original polygon boundary). Non-constraint edges in the TIN become the initial neighbor links between {@code KineticTriangle}s.</li>
 * </ul>
 * After initialization, the {@code KineticTriangulation} evolves independently based on kinetic events, modifying its own structure. The original TinFour TIN is no longer directly used for navigation, although references to original TinFour elements ({@code Vertex}, {@code SimpleTriangle}, {@code IQuadEdge}) are kept for potential debugging or mapping back. TinFour navigation methods like {@code getContainingTriangle} or {@code getNearestEdge} operate on the *initial*, static TIN, not the evolving kinetic structure.
 *
 * <h2>Constraint Handling:</h2>
 * Edges from the input polygon boundary are treated specially. They are represented by:
 * <ol>
 *     <li>Constraints in the initial TinFour triangulation ({@code IQuadEdge.isConstraint() == true}).</li>
 *     <li>{@link KineticEdge} objects in this kinetic structure.</li>
 * </ol>
 * These {@code KineticEdge} objects:
 * <ul>
 *     <li>Store the weight associated with the original polygon edge (determining its offset speed).</li>
 *     <li>Define the initial wavefront boundary.</li>
 *     <li>Participate in the velocity calculation for their endpoint {@code KineticVertex} objects.</li>
 *     <li>Are subject to {@link EventType#EDGE_COLLAPSE} events when their endpoints meet.</li>
 *     <li>Are *not* subject to {@link EventType#FLIP_EVENT}s. Flips only occur across internal "spoke" edges (represented by neighbor links).</li>
 * </ul>
 *
 * <h2>Usage:</h2>
 * <ol>
 *     <li>Create an {@link InitialTriangulator} and run {@code triangulate()}.</li>
 *     <li>Instantiate {@code KineticTriangulation} with the result.</li>
 *     <li>Create an {@link EventQueue}.</li>
 *     <li>Call {@code initialize(eventQueue)} to build the kinetic structure and populate the initial events.</li>
 *     <li>Loop while the event queue is not empty:</li>
 *          <ul>
 *              <li>Get the next event using {@code eventQueue.poll()}.</li>
 *              <li>Update current time.</li>
 *              <li>Call {@code handleEvent(event)} to process the event and update the kinetic structure. This method also queues updates for affected triangles' next events.</li>
 *          </ul>
 *     <li>Once the queue is empty, call {@code generateSkeletonOutput()} to construct the final skeleton structure.</li>
 * </ol>
 */
public class KineticTriangulation {

    private final InitialTriangulator initialTriangulator;
    private final IIncrementalTin tin; // Keep a reference to the initial TIN
    private List<KineticVertex> vertices;
    private List<KineticEdge> edges; // Only wavefront edges
    private List<KineticTriangle> triangles;

    // Mappings for initialization and lookup
    private Map<Vertex, KineticVertex> tinVertexToKVMap;
    private Map<IQuadEdge, KineticEdge> tinEdgeToKEMap; // Maps constraint edges (and twins) to KineticEdge
    private Map<SimpleTriangle, KineticTriangle> tinTriToKTMap;

    private EventQueue eventQueue; // Set externally
    private boolean initialized = false;

    // --- Statistics/Counters (Copied from C++) ---
    public long[] eventTypeCounter = new long[EventType.values().length];
    public int maxTrianglesPerEdgeEvent = 0;
    public long avgTrianglesPerEdgeEventSum = 0;
    public long avgTrianglesPerEdgeEventCtr = 0;
    public int maxTrianglesPerSplitEvent = 0; // Assuming split event added later
    public long avgTrianglesPerSplitEventSum = 0;
    public long avgTrianglesPerSplitEventCtr = 0;
    public double lastEventTime = 0.0;
    public int eventsPerCurrentEventTime = 0;
    public int maxEventsPerTime = 0;
    public long avgEventsPerTimeSum = 0;
    public long avgEventsPerTimeCtr = 0;

    public KineticTriangulation(InitialTriangulator initialTriangulator) {
        this.initialTriangulator = Objects.requireNonNull(initialTriangulator);
        this.tin = initialTriangulator.getTin();
        this.vertices = new ArrayList<>();
        this.edges = new ArrayList<>();
        this.triangles = new ArrayList<>();
        this.tinVertexToKVMap = new HashMap<>();
        this.tinEdgeToKEMap = new HashMap<>();
        this.tinTriToKTMap = new HashMap<>();
    }

    /**
     * Initializes the kinetic data structures based on the initial triangulation
     * and populates the event queue with the first set of collapse events.
     *
     * @param queue The event queue to use for the simulation.
     */
    public void initialize(EventQueue queue) {
        if (initialized) {
            throw new IllegalStateException("KineticTriangulation already initialized.");
        }
        this.eventQueue = Objects.requireNonNull(queue);

        System.out.println("  KT: Creating Kinetic Vertices...");
        createKineticVertices();
        System.out.println("  KT: Creating Kinetic Edges (Wavefront)...");
        createKineticEdges();
        System.out.println("  KT: Creating Kinetic Triangles...");
        createKineticTriangles();
        System.out.println("  KT: Establishing Connectivity and Velocities...");
        establishConnectivityAndVelocities(); // Renamed for clarity
        System.out.println("  KT: Calculating Initial Events...");
        calculateInitialEvents();

        initialized = true;
        System.out.println("  KT: Initialization complete.");
    }

    // Step 1: Create KineticVertex for each TinFour Vertex
    private void createKineticVertices() {
        tinVertexToKVMap.clear();
        vertices.clear();
        for (Vertex v : tin.getVertices()) {
            // Initial velocity calculated later in establishConnectivityAndVelocities
            KineticVertex kv = new KineticVertex(v, Vector2D.create(0, 0), 0.0);
            vertices.add(kv);
            tinVertexToKVMap.put(v, kv);
        }
        System.out.println("    Created " + vertices.size() + " Kinetic Vertices.");
    }

    // Step 2: Create KineticEdge for each TinFour *constraint* edge
    private void createKineticEdges() {
        tinEdgeToKEMap.clear();
        edges.clear();
        Map<IQuadEdge, Double> constraintWeights = initialTriangulator.getConstraintWeightsMap();

        for (IQuadEdge edge : tin.getEdges()) {
            // Process only constraint edges, and only one representative per pair (edge/twin)
            if (edge.isConstraintLineMember() && !tinEdgeToKEMap.containsKey(edge) && !tinEdgeToKEMap.containsKey(edge.getDual())) {
                Vertex vA = edge.getA();
                Vertex vB = edge.getB();
                KineticVertex kvA = tinVertexToKVMap.get(vA);
                KineticVertex kvB = tinVertexToKVMap.get(vB);

                if (kvA != null && kvB != null) {
                    // Weight defaults to 1.0 if somehow not in map, but should be present
                    double weight = constraintWeights.getOrDefault(edge, Constants.DEFAULT_WEIGHT);
                    // Ensure kvA is "start" and kvB is "end" consistently if needed, though KineticEdge handles internal order.
                    KineticEdge ke = new KineticEdge(kvA, kvB, weight, edge);
                    edges.add(ke);
                    tinEdgeToKEMap.put(edge, ke);
                    tinEdgeToKEMap.put(edge.getDual(), ke); // Map twin too
                } else {
                    System.err.println("Error: Could not find KineticVertices for constraint edge " + edge + " (Vertices: " + vA + ", " + vB + ")");
                }
            }
        }
        System.out.println("    Created " + edges.size() + " Kinetic Edges (Wavefront).");
    }

    // Step 3: Create KineticTriangle for each TinFour SimpleTriangle
    private void createKineticTriangles() {
        tinTriToKTMap.clear();
        triangles.clear();
        List<SimpleTriangle> tinTriangles;// = tin.getTriangles(); // Use the cached list if available
        tinTriangles = initialTriangulator.getTriangles();
        if (tinTriangles == null || tinTriangles.isEmpty()) {
             System.err.println("Error: No triangles found in the initial TIN.");
             return;
        }

        for (SimpleTriangle tinTri : tinTriangles) {
            Vertex v0 = tinTri.getVertexA();
            Vertex v1 = tinTri.getVertexB();
            Vertex v2 = tinTri.getVertexC();

            KineticVertex kv0 = tinVertexToKVMap.get(v0);
            KineticVertex kv1 = tinVertexToKVMap.get(v1);
            KineticVertex kv2 = tinVertexToKVMap.get(v2);

            if (kv0 != null && kv1 != null && kv2 != null) {
                KineticTriangle kt = new KineticTriangle(kv0, kv1, kv2, tinTri);
                triangles.add(kt);
                tinTriToKTMap.put(tinTri, kt);
            } else {
                System.err.println("Error: Could not find all KineticVertices for triangle " + tinTri);
            }
        }
        System.out.println("    Created " + triangles.size() + " Kinetic Triangles.");
    }

    // Step 4: Link triangles, edges, neighbors, and calculate initial vertex velocities
    private void establishConnectivityAndVelocities() {
        // 4a. Link Triangles to Edges and Neighbors
        for (KineticTriangle kt : triangles) {
            SimpleTriangle tinTri = kt.originalTinTriangle;
            if (tinTri == null) continue; // Should not happen if created correctly

            for (int i = 0; i < 3; i++) {
                // Edge index i in KineticTriangle is opposite vertex i
                // Tinfour SimpleTriangle.getEdge(j) gets edge opposite vertex j (A=0, B=1, C=2)
                // We need to map kt vertex indices to tinTri vertex indices (A,B,C)
                Vertex ktVertex = kt.getVertex(i).getOriginalTinVertex();
                int tinVertexIndex = -1;
                if (ktVertex == tinTri.getVertexA()) tinVertexIndex = 0;
                else if (ktVertex == tinTri.getVertexB()) tinVertexIndex = 1;
                else if (ktVertex == tinTri.getVertexC()) tinVertexIndex = 2;

                if (tinVertexIndex == -1) {
                     System.err.println("Error establishing connectivity: Vertex mismatch for KT " + kt.id);
                     continue;
                }

                IQuadEdge tinEdge = null;// NOTE uncomment -> = tinTri.getEdge(tinVertexIndex); // Get edge opposite vertex i in TIN

                // Check if this TIN edge corresponds to a KineticEdge (i.e., is a constraint)
                KineticEdge ke = tinEdgeToKEMap.get(tinEdge);
                if (ke != null) {
                    // It's a wavefront edge
                    kt.setEdge(i, ke);
                    kt.setNeighbor(i, null);
                    ke.setIncidentTriangle(kt); // Ensure edge points back
                } else {
                    // It's an internal edge (spoke)
                    kt.setEdge(i, null);
                    IQuadEdge twin = tinEdge.getDual();
                    SimpleTriangle neighborTinTri = null;// // NOTE uncomment -> = tin.getTriangle(twin);
                    if (neighborTinTri != null) {
                        KineticTriangle neighborKt = tinTriToKTMap.get(neighborTinTri);
                        kt.setNeighbor(i, neighborKt);
                    } else {
                        // Should not happen for internal edges unless on convex hull of TIN points
                        kt.setNeighbor(i, null);
                         System.err.println("Warning: No neighbor found across non-constraint edge for KT " + kt.id + ", edge opposite vertex " + i);
                    }
                }
            }
        }
        System.out.println("    Connectivity: Triangle neighbors and edges linked.");

        // 4b. Link Vertices to Edges and Calculate Initial Velocities
        for (KineticVertex kv : vertices) {
            Vertex tinV = kv.originalTinVertex;
            if (tinV == null) continue; // Skip synthetic vertices (none yet)

            List<KineticEdge> incidentWavefrontEdges = new ArrayList<>();
            // Use pinwheel iterator to find incident constraint edges efficiently
         // NOTE uncomment ->
//            for (IQuadEdge edge : tin.pinwheel(tinV)) {
//                KineticEdge ke = tinEdgeToKEMap.get(edge); // Check if it's a constraint edge we mapped
//                if (ke != null) {
//                     // Avoid adding the same edge twice (if edge and twin were both checked)
//                     if (!incidentWavefrontEdges.contains(ke)) {
//                          incidentWavefrontEdges.add(ke);
//                     }
//                }
//            }

            if (incidentWavefrontEdges.size() == 2) {
                KineticEdge edge1 = incidentWavefrontEdges.get(0);
                KineticEdge edge2 = incidentWavefrontEdges.get(1);

                // Determine CW/CCW order relative to the vertex kv
                // We need the other endpoints of the edges
                KineticVertex other1 = (edge1.getVertex(0) == kv) ? edge1.getVertex(1) : edge1.getVertex(0);
                KineticVertex other2 = (edge2.getVertex(0) == kv) ? edge2.getVertex(1) : edge2.getVertex(0);

                // Check orientation kv -> other1 -> other2
                double orient = GeometryUtil.orientation(kv.posZero, other1.posZero, other2.posZero);

                KineticEdge cwEdge, ccwEdge;
                if (orient > Constants.EPSILON) { // kv->other1->other2 is CCW
                    cwEdge = edge2;
                    ccwEdge = edge1;
                } else if (orient < -Constants.EPSILON) { // kv->other1->other2 is CW
                    cwEdge = edge1;
                    ccwEdge = edge2;
                } else {
                    // Collinear case - should correspond to straight angle vertex
                     System.err.println("Warning: Collinear incident wavefront edges detected for KV " + kv.id + ". Velocity calculation might be simplified.");
                     // Assign arbitrarily for now, velocity calc should handle it
                     cwEdge = edge1;
                     ccwEdge = edge2;
                }

                kv.setIncidentEdges(cwEdge, ccwEdge); // Set consistently

                // Calculate velocity (now that we have the correctly ordered incident edges)
                Vector2D vel = GeometryUtil.calculateVelocity(kv.posZero,
                        cwEdge.getSegmentAt(0), // Use segment at t=0
                        ccwEdge.getSegmentAt(0),
                        cwEdge.getWeight(), ccwEdge.getWeight());

                // Update the vertex's velocity (Requires mutable field or recreation)
                // HACK: Directly modify velocity (make KineticVertex.velocity non-final for this)
                 // kv.velocity = vel; // Requires velocity to be non-final
                 // Or recreate the vertex instance in the list
                 int index = vertices.indexOf(kv);
                 if (index != -1) {
                     vertices.set(index, new KineticVertex(kv.posZero, vel, kv.timeStart, kv.originalTinVertex));
                     // Update map reference
                     tinVertexToKVMap.put(tinV, vertices.get(index));
                     // Update references in edges (IMPORTANT!)
                      cwEdge.updateVertexRef(vertices.get(index));
                      ccwEdge.updateVertexRef(vertices.get(index));
                 } else {
                     System.err.println("Critical Error: Could not find KV "+ kv.id +" in list for velocity update.");
                 }

            } else if (incidentWavefrontEdges.isEmpty()) {
                 System.err.println("Error: Vertex KV " + kv.id + " (Tin: "+tinV+") has no incident wavefront edges. Likely an internal vertex of the original polygon fill - should not happen with simple polygon input.");
            } else {
                 System.err.println("Warning: Vertex KV " + kv.id + " (Tin: "+tinV+") has " + incidentWavefrontEdges.size() + " incident wavefront edges. Expected 2 for simple polygon vertex. Beveling/complex handling needed.");
                 // Assign first two arbitrarily for now, velocity will be approximate
                  if (incidentWavefrontEdges.size() >= 2) {
                      kv.setIncidentEdges(incidentWavefrontEdges.get(0), incidentWavefrontEdges.get(1));
                  } else if (incidentWavefrontEdges.size() == 1){
                       kv.setIncidentEdges(incidentWavefrontEdges.get(0), null); // Or handle specifically
                  }
            }
        }
         // Re-iterate through triangles to update vertex references after potential recreation
         for(KineticTriangle kt : triangles) {
             for(int i=0; i<3; i++) {
                 Vertex originalV = kt.getVertex(i).getOriginalTinVertex();
                 if (originalV != null) {
                      KineticVertex updatedV = tinVertexToKVMap.get(originalV);
                      if (updatedV != kt.getVertex(i)) {
                           System.out.println("Updating vertex ref in KT " + kt.id);
                           kt.vertices[i] = updatedV; // Requires vertices array to be modifiable
                      }
                 }
             }
         }

        System.out.println("    Connectivity: Vertex velocities calculated.");
    }

    // Step 5: Calculate initial events for all triangles
    private void calculateInitialEvents() {
        int count = 0;
        for (KineticTriangle kt : triangles) {
            if (!kt.hasStopped()) { // Should not be stopped yet
                CollapseEvent event = kt.computeCollapseEvent(0.0);
                if (event.getType() != EventType.NONE) {
                    eventQueue.add(event);
                    count++;
                }
            }
        }
        System.out.println("    Calculated " + count + " initial events. Queue size: " + eventQueue.size());
    }

    // --- Event Handling (Modified Signatures) ---

    /**
     * Processes a collapse event, updating the kinetic triangulation structure.
     * This method dispatches to specific handlers based on the event type.
     * After handling, it queues updates for the events of affected triangles.
     *
     * @param event The collapse event to handle.
     */
    public void handleEvent(CollapseEvent event) {
        // Basic assertion: event time should not go backwards
        if (event.getTime() < lastEventTime - Constants.EPSILON) {
             System.err.println("CRITICAL ERROR: Event time regression! Last: " + lastEventTime + ", Event: " + event);
             // Consider throwing an exception or stopping simulation
             return;
        }
         // Update stats
         updateEventTimingStats(event.getTime());
         eventTypeCounter[event.getType().ordinal()]++;


        System.out.println("Handling event: " + event);
        KineticTriangle triangle = event.getTriangle();
        if (triangle.hasStopped()) {
            System.out.println("  Triangle " + triangle.id +" already stopped. Skipping event.");
            return; // Already processed
        }

        double time = event.getTime();

        switch (event.getType()) {
            case EDGE_COLLAPSE:
                handleEdgeCollapse(event, time);
                break;
            case TRIANGLE_COLLAPSE:
                 handleTriangleCollapse(event, time);
                break;
            case FLIP_EVENT:
                 handleFlipEvent(event, time);
                break;
            // TODO Add cases for SPOKE_COLLAPSE, SPLIT_EVENT etc. when implemented
            default:
                System.err.println("Unhandled event type in KineticTriangulation: " + event.getType());
        }

        // Invalidate events of affected neighbors (and the triangle itself if it wasn't stopped)
        // The specific handlers should ideally do this more precisely for the elements they modify.
        // updateAffectedEvents(triangle, time); // General fallback, might be redundant/inefficient
    }

    // --- Event Handlers (Placeholders - need full implementation) ---

    private void handleEdgeCollapse(CollapseEvent event, double time) {
        // ... (Implementation similar to previous version, ensuring updates to
        //      vertices, edges, triangles, neighbors, and event queue) ...
         System.out.println("  Handling EDGE_COLLAPSE for T" + event.getTriangle().id);
         // Mark elements as stopped
         // Create new vertex
         // Update topology (neighbor links, vertex references in triangles)
         // Update event queue for affected elements
         // ... Full implementation needed ...

          KineticTriangle t = event.getTriangle();
          int edgeIndex = event.getEdgeIndex();
          KineticEdge edge = t.getEdge(edgeIndex);

          if (edge == null || edge.hasStopped() || t.hasStopped()) {
              System.out.println("  Edge/Triangle already stopped.");
              return;
          }

          KineticVertex v0 = edge.getVertex(0);
          KineticVertex v1 = edge.getVertex(1);

          if (v0.hasStopped() || v1.hasStopped()){
              System.out.println("  Edge endpoints already stopped.");
               edge.stop(); // Ensure edge is marked stopped too
              return;
          }


          edge.stop();
          v0.stop(time);
          v1.stop(time);
          t.stop(); // Triangle is consumed by edge collapse

          Coordinate collisionPoint = v0.getPosStop();
          KineticEdge edgeA = v0.getIncidentEdge(0); // CW from v0
          KineticEdge edgeB = v1.getIncidentEdge(1); // CCW from v1

          if (edgeA == null || edgeB == null) {
              System.err.println("Error: Null edge encountered during edge collapse vertex creation at vertex " + v0.id + " or " + v1.id + ". Boundary case?");
               // Need robust handling for skeleton reaching polygon boundary vertices
               return;
          }

          KineticVertex newVertex = KineticVertex.createEventVertex(collisionPoint, time, edgeA, edgeB);
          vertices.add(newVertex);

          // Link the skeleton path
          v0.setNext(newVertex);
          newVertex.setPrev(v0);
          v1.setPrev(newVertex);
          newVertex.setNext(v1);

          // Update vertex references in neighboring triangles and recalculate their events
          updateVertexReferences(v0, newVertex, time);
          updateVertexReferences(v1, newVertex, time);

          // Update neighbor pointers of triangles adjacent to t across non-collapsed edges
          updateNeighborLinks(t, edgeIndex, time);

          System.out.println("  Edge Collapse complete. New vertex KV" + newVertex.id);
    }

    private void handleTriangleCollapse(CollapseEvent event, double time) {
        // ... (Implementation similar to previous version) ...
         System.out.println("  Handling TRIANGLE_COLLAPSE for T" + event.getTriangle().id);
         // Mark triangle, its vertices, and its wavefront edges as stopped
         // Update topology (neighbor links)
         // Update event queue for affected neighbors
         // ... Full implementation needed ...

         KineticTriangle t = event.getTriangle();
         if (t.hasStopped()) return;
         t.stop();

         KineticVertex v0=null, v1=null, v2=null;
         for (int i = 0; i < 3; i++) {
             KineticVertex v = t.getVertex(i);
             if (!v.hasStopped()) v.stop(time);
             if (i==0) v0=v; else if (i==1) v1=v; else v2=v;

             KineticEdge edge = t.getEdge(i); // Edge opposite vertex i
             if (edge != null && !edge.hasStopped()) edge.stop();
         }

         // Link skeleton path
         if(v0 != null && v1 != null && v2 != null) {
             v0.setNext(v1); v1.setPrev(v0);
             v1.setNext(v2); v2.setPrev(v1);
             v2.setNext(v0); v0.setPrev(v2);
         }

         // Update neighbors
         for (int i = 0; i < 3; i++) {
              updateNeighborLinks(t, i, time); // Update link for neighbor opposite vertex i
         }
         System.out.println("  Triangle Collapse complete.");
    }

    private void handleFlipEvent(CollapseEvent event, double time) {
        // ... (Implementation similar to previous version, requires complex topology update) ...
         System.out.println("  Handling FLIP_EVENT for T" + event.getTriangle().id + " (Not fully implemented)");
         // Find the two triangles involved
         // Perform the vertex swap
         // Update all edge/neighbor pointers for both triangles
         // Update event queue for both triangles and potentially their *new* neighbors
         // ... Full implementation needed ...
    }

    // --- Helper Methods ---

    /** Helper to update vertex references in triangles adjacent to a stopped vertex. */
    private void updateVertexReferences(KineticVertex oldVertex, KineticVertex newVertex, double time) {
        // Iterate through *active* triangles only
        for (KineticTriangle tri : getActiveTriangles()) { // More efficient than iterating all
             for (int i = 0; i < 3; i++) {
                 if (tri.getVertex(i) == oldVertex) {
                     System.out.println("    Updating vertex ref in T" + tri.id + " from KV" + oldVertex.id + " to KV" + newVertex.id);
                     tri.vertices[i] = newVertex; // Direct update
                     eventQueue.update(tri, time); // Mark for event recalculation
                     // Also update the vertex's reference back to its incident edges if needed
                      KineticEdge edgeCW = tri.getEdge((i+2)%3); // Edge opposite next vertex (CW)
                      KineticEdge edgeCCW = tri.getEdge((i+1)%3); // Edge opposite prev vertex (CCW)
                      // If these are wavefront edges, ensure newVertex knows about them
                      // This requires careful check: is the edge actually incident *now*?
                      // Simpler: Rely on KineticVertex constructor/update methods to handle this?
                     break;
                 }
             }
        }
    }

    /** Helper to update neighbor links when a triangle 't' is removed. */
    private void updateNeighborLinks(KineticTriangle t, int edgeIndexOppositeNeighbor, double time) {
         KineticTriangle neighbor = t.getNeighbor(edgeIndexOppositeNeighbor);
         if (neighbor != null && !neighbor.hasStopped()) {
             int indexInNeighbor = neighbor.getNeighborIndex(t);
             if (indexInNeighbor != -1) {
                 System.out.println("    Updating neighbor link: T" + neighbor.id + " no longer neighbors stopped T" + t.id);
                 neighbor.setNeighbor(indexInNeighbor, null); // Remove link to stopped triangle
                 // If the edge between them was internal, it might become a wavefront edge now.
                 // This requires creating a new KineticEdge - complex, defer for now.
                 // For simplicity, just recalculate neighbor's event.
                 eventQueue.update(neighbor, time);
             } else {
                  System.err.println("Warning: Neighbor T" + neighbor.id + " didn't have T" + t.id + " as neighbor at expected index.");
             }
         }
    }

     /** Update statistics for event timing */
     private void updateEventTimingStats(double now) {
         if (Math.abs(now - lastEventTime) > Constants.EPSILON || avgEventsPerTimeCtr == 0) {
             // New time step or first event
             if (avgEventsPerTimeCtr > 0) { // Don't record stats for the very first event's "step"
                 maxEventsPerTime = Math.max(maxEventsPerTime, eventsPerCurrentEventTime);
                 avgEventsPerTimeSum += eventsPerCurrentEventTime;
                 avgEventsPerTimeCtr++;
             }
             lastEventTime = now;
             eventsPerCurrentEventTime = 1;
         } else {
             // Same time step
             eventsPerCurrentEventTime++;
         }
     }

     /** Finalize statistics after the last event */
     public void finalizeStats() {
          if (avgEventsPerTimeCtr > 0) { // Record stats for the last time step
              maxEventsPerTime = Math.max(maxEventsPerTime, eventsPerCurrentEventTime);
              avgEventsPerTimeSum += eventsPerCurrentEventTime;
              avgEventsPerTimeCtr++;
          }
     }


    // --- Getters ---
    public List<KineticTriangle> getActiveTriangles() {
        List<KineticTriangle> active = new ArrayList<>();
        for(KineticTriangle t : triangles) {
            if (!t.hasStopped()) active.add(t);
        }
        return active;
    }
     public List<KineticVertex> getVertices() { return vertices; }
     public List<KineticEdge> getWavefrontEdges() { return edges; } // Renamed for clarity

     public IIncrementalTin getInitialTin() { return tin; }


     // --- Output Generation ---
     public SkeletonOutput generateSkeletonOutput() {
         List<LineSegment> arcs = new ArrayList<>();
         // Iterate through vertices and construct segments/rays from prev/next links
         List<KineticVertex> processedStarts = new ArrayList<>(); // Avoid duplicates if graph has loops

         for (KineticVertex v : vertices) {
              // Start tracing from vertices that have a 'prev' link but haven't been started from
             if (v.getPrev() != null && !processedStarts.contains(v)) {
                 KineticVertex current = v;
                  // Follow the 'prev' links backward in time towards the start of the arc(s)
                 while (current.getPrev() != null && current.getPrev() != v && !processedStarts.contains(current.getPrev())) {
                      processedStarts.add(current); // Mark intermediate as processed
                     current = current.getPrev();
                 }
                  processedStarts.add(current); // Mark the ultimate start as processed

                  // Now trace forward using 'next' links to build segments/rays
                  while (current != null && current.getNext() != null && current.getNext() != current) { // Follow chain
                      KineticVertex next = current.getNext();

                      if (current.hasStopped() && next.hasStopped()) {
                          // Finite segment
                          Coordinate p1 = current.getPosStop();
                          Coordinate p2 = next.getPosStop();
                          if (p1 != null && p2 != null && p1.distance(p2) > Constants.EPSILON) {
                              arcs.add(new LineSegment(p1, p2));
                          } else if (p1 != null && p2 != null) {
                               System.out.println("Skipping zero-length skeleton segment between KV"+current.id+" and KV"+next.id);
                          }
                      } else if (current.hasStopped() && !next.hasStopped()) {
                          // Ray starting from current's stop point
                          Coordinate startPoint = current.getPosStop();
                          Vector2D direction = next.getVelocity(); // Ray follows velocity of the moving end
                          if (startPoint != null && direction.length() > Constants.EPSILON) {
                              // Represent ray as a long segment for visualization
                              double rayLength = 1000.0; // Arbitrary large length
                              Coordinate endPoint = new Coordinate(
                                      startPoint.x + direction.getX() * rayLength,
                                      startPoint.y + direction.getY() * rayLength);
                              arcs.add(new LineSegment(startPoint, endPoint));
                               System.out.println("Generated RAY from KV"+current.id);
                          }
                      } else {
                           // Should not have !current.hasStopped() if we started from a stopped vertex backward trace
                           System.err.println("Unexpected state in skeleton tracing at KV"+current.id);
                      }

                      if (processedStarts.contains(next)) break; // Already traced this part from another start
                      processedStarts.add(next);
                      current = next;
                  }
             }
         }
          System.out.println("Generated " + arcs.size() + " skeleton arcs.");
         return new SkeletonOutput(arcs);
     }
}